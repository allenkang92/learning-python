### 1. 제너레이터 (Generator) 심화

- **제너레이터 2가지 종류:**
    1. **제너레이터 표현식 (Generator Expression):** (표현식 for 변수 in 이터러블) 형태. 튜플 컴프리헨션과 유사한 문법. <genexpr> 타입.
    2. **제너레이터 함수 (Generator Function):** 함수 내부에 yield 키워드 사용. def 함수이름(): yield 값. <generator> 타입.
- **제너레이터 특징:**
    - **Lazy Evaluation (지연 평가):** 데이터 요청 시점에 생성 (next() 호출 시). 메모리 효율적.
    - **Iterator (이터레이터) 의 일종:** __iter__(), __next__() 메소드 내장. next() 함수로 값 순차적으로 접근 가능.
    - **순차 접근만 가능:** 인덱싱, 슬라이싱 등 임의 접근 **불가**.
- **제너레이터 표현식 예시:**

```python
a = (x for x in range(10)) # 제너레이터 표현식
print(a) # <generator object <genexpr> at 0x...>
print(next(a)) # 0 (첫 번째 값 생성 및 반환)
print(next(a)) # 1 (두 번째 값 생성 및 반환)
```

- **제너레이터 객체 속성 확인:** dir(a) 로 제너레이터 객체의 속성 및 메소드 확인 가능. __iter__, __next__, send, throw, close 등 확인.

### 2. 이터레이터 (Iterator) 와 이터러블 (Iterable)

- **이터러블 (Iterable):**
    - **순회 가능 (iteration)** 한 객체.
    - **__iter__() 메소드** 를 가진 객체. dir(객체) 로 __iter__ 메소드 존재 여부 확인 가능.
    - for 루프, sum(), all(), any() 등 함수에 인자로 전달 가능.
    - 예시: 리스트, 튜플, 문자열, 딕셔너리, 셋, 제너레이터.
- **이터레이터 (Iterator):**
    - **값을 순차적으로 생성** 하는 객체.
    - **__iter__() 와 __next__() 메소드** 를 모두 가진 객체.
    - **__iter__()**: 자기 자신 (iterator 객체) 반환.
    - **__next__()**: 다음 값 반환, 더 이상 값이 없으면 StopIteration 예외 발생.
    - **iter(iterable)**: 이터러블 객체를 인자로 받아 **이터레이터 객체** 를 반환하는 내장 함수.
    - **next(iterator)**: 이터레이터 객체에서 **다음 값** 을 반환하는 내장 함수.
- **for 루프 내부 동작 방식:**
    1. for 루프에 이터러블 객체 전달.
    2. iter(iterable) 호출하여 **이터레이터 객체 생성**.
    3. next(iterator) 호출하여 **이터레이터에서 값 순차적으로 가져옴**.
    4. 가져온 값을 루프 변수에 할당, 코드 블록 실행.
    5. StopIteration 예외 발생 시 루프 종료 (else 블록 실행 - 있는 경우).
- **이터레이터 프로토콜 (Iterator Protocol):** 이터레이터가 되기 위한 규칙. __iter__(), __next__() 메소드 구현.

### 3. all(), any() 함수

- **all(iterable)**: 이터러블의 **모든 요소** 가 **True** (존재론적 True) 이면 True 반환, 아니면 False 반환.
    - **진위 판별**: 이터러블 요소들의 진위값을 **AND 연산** 하듯이 평가.
- **any(iterable)**: 이터러블의 **하나 이상의 요소** 가 **True** (존재론적 True) 이면 True 반환, 아니면 False 반환.
    - **진위 판별**: 이터러블 요소들의 진위값을 **OR 연산** 하듯이 평가.

### 4. in, not in 연산자 심화 (멤버십 테스트)

- **멤버십 테스트**: 특정 요소가 컨테이너 (이터러블) 에 **속하는지** 여부 확인.
- **in 연산자**: 요소가 컨테이너에 **존재하면 True**, 아니면 False 반환.
- **not in 연산자**: 요소가 컨테이너에 **존재하지 않으면 True**, 아니면 False 반환 (in 연산자의 반대).
- **컨테이너 타입별 동작 방식**:
    - **시퀀스 (리스트, 튜플, 문자열):** 요소 값 **순차 비교**.
    - **셋, frozenset:** **해시 기반** 멤버십 테스트 (빠른 검색).
    - **딕셔너리:** **키 (Key) 멤버십 테스트**. 값 (Value) 은 검색하지 않음.
- **help('in')**: in 연산자 상세 도움말 확인. __contains__(), __iter__(), __getitem__() 메소드 관련 설명 포함.

### 5. 컴프리헨션 vs. 제너레이터 컴프리헨션 비교

| 특징 | 리스트 컴프리헨션 ([]) | 제너레이터 컴프리헨션 (()) |
| --- | --- | --- |
| 문법 | [표현식 for ...] | (표현식 for ...) |
| 생성 객체 | 리스트 (list) | 제너레이터 (generator) |
| 평가 방식 | Eager evaluation (즉시 평가) | Lazy evaluation (지연 평가) |
| 메모리 사용량 | 큼 (전체 데이터 메모리 로드) | 작음 (요청 시점에 데이터 생성) |
| 성능 | 초기 생성 시간 오래 걸림 | 초기 생성 시간 매우 빠름 |
| 활용 | 작은 데이터셋, 결과 리스트 필요 | 대용량 데이터셋, 메모리 효율 중시 |
| 딥러닝 적합성 | 낮음 (메모리 문제) | 높음 (데이터 로딩, 파이프라인) |
| 데이터 분석 적합성 | 빠르고 간결 (작은 데이터) | 메모리 효율적 (큰 데이터) |

### 6. 함수형 프로그래밍 심화: 람다 대수, 고차 함수, map()

- **함수형 프로그래밍 특징 복습**: First-class functions, Higher-order functions, Pure functions, Immutability, Recursion.
- **람다 대수 (Lambda Calculus):**
    - **함수와 함수의 연산** 으로 계산 추상화. 튜링 기계와 동치, 모든 기계적 계산 표현 가능.
    - **알론조 처치 (Alonzo Church) 고안**: 1930년대.
    - **익명 함수 (Anonymous Function):** λ(매개 변수).(함수식) 형태. 이름 없는 함수 표현.
    - **커링 (Currying):** 다변수 함수 -> 일변수 함수 연속 변환.
    - **람다 항, 변환 규칙, 정규형 등**: 람다 대수 심층 내용 간략히 소개 (자세한 내용은 "람다 대수 정리" 참고).
    - **처치-튜링 명제**: 기계적으로 계산 가능한 함수는 튜링 계산 가능, 람다 계산 가능.
- **람다 함수 (Lambda Function):** 람다 대수 개념을 파이썬에 구현한 익명 함수. lambda 인자: 표현식 형태.
- **고차 함수 (Higher-Order Function):**
    - **함수를 인자로 받거나, 함수를 반환하는 함수**.
    - **합성 함수 (Composition of Functions) 와 유사**: 함수를 조합하여 더 복잡한 기능 구현.
    - **함수형 프로그래밍 핵심**: 코드 재사용성, 추상화, 모듈성 향상.
    - **map() 함수**: 대표적인 고차 함수. 함수와 이터러블을 인자로 받아, 이터러블 각 요소에 함수 적용 결과를 이터레이터로 반환.
- **map() 함수 활용**:
    - **map(function, iterable)**: 이터러블 각 요소에 function 적용.
    - **Lazy evaluation**: map() 함수 결과는 이터레이터. next() 또는 루프 통해 값 순차적으로 접근.
    - **데이터 변환, 데이터 파이프라인 구축** 에 유용.
    - **람다 함수와 함께 사용**: 간단한 함수를 람다 함수로 정의하여 map() 함수와 함께 사용.

### 9. 함수형 프로그래밍 vs. 명령형 프로그래밍 비교 (장단점)

- **함수형 프로그래밍 (FP):**
    - **장점**: 간결성, 가독성, side effect 감소, 테스트 용이성, 동시성, 형식적 증명 가능성.
    - **단점**: 러닝 커브 높음, 성능 (재귀), 특정 문제에 대한 비효율성.
    - **주요 활용 분야**: 데이터 분석, 인공지능 (딥러닝), 학문적 프로그래밍.
- **명령형 프로그래밍 (Imperative Programming):**
    - **장점**: 직관적, 배우기 쉬움, 성능 (반복문), 다양한 문제 해결에 범용적.
    - **단점**: 코드 복잡성 증가, side effect, 디버깅 어려움, 병렬 처리 어려움.
- **파이썬, 다중 패러다임 언어**: 함수형, 명령형, 객체지향 등 다양한 패러다임 지원. **상황에 맞게 적절한 패러다임 선택** 중요.