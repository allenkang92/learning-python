### 1. 식별자 (Identifier) vs. 변수 (Variable)

- **파이썬 관점:** "변수"라는 용어 대신 **식별자**를 사용하는 것이 더 정확합니다.
- **식별자:** 어떤 **객체**를 가리키는 이름표와 같습니다. 레퍼런스(참조)를 통해 객체를 식별합니다.
- **변수 (프로그래밍 관점):** 일반적인 프로그래밍 언어에서 변수는 값을 저장하는 공간으로 생각하지만, 파이썬에서는 이름이 객체를 "가리키는" 개념입니다.
- **상수 (Constant):** 파이썬에는 상수 개념이 **없습니다**. 이름을 통해 값을 변경할 수 있습니다.

      `a = 10  # a는 식별자, 10은 객체 (정수)
a = 20  # a는 이제 다른 객체 (20)를 가리킴`

### 2. 표현식 (Expression) vs. 정의문 (Statement)

- **표현식 (Expression):** **하나의 값**으로 축약될 수 있는 코드 조각입니다. 연산, 함수 호출 등이 표현식에 해당합니다. 표현식은 값을 만들어냅니다.
    - 예시: 1 + 1, lambda x: x + 1, [1, 2, 3], {'a': 1}
- **정의문 (Statement):** **어떤 행위**를 지시하는 코드입니다. 할당문 (=), 함수 정의 (def), 클래스 정의 (class) 등이 정의문에 해당합니다. 정의문은 값을 만들어내기보다는, 프로그램의 구조나 상태를 변경합니다.
    - 예시: a = 1 + 1, def my_function(): pass, class MyClass: pass
- **람다 함수 (Lambda Function):** **함수 표현식**입니다. 익명 함수라고도 불리며, 주로 **일회성**으로 사용됩니다.
    - 람다 함수를 식별자에 할당하는 것은 **별칭(alias) 또는 바인딩(binding)**을 만드는 것입니다.

      `a = 1 + 1       # 할당문 (정의문), 1+1은 표현식
b = lambda x: x+1 # 할당문 (정의문), lambda x: x+1은 람다 표현식 (함수식)
print(a)         # 함수 호출 (표현식)`

### 3. 명명 규칙 (Naming Convention)

- **PEP 8:** 파이썬 코딩 스타일 가이드라인입니다. **가독성**과 **협업**을 위해 중요합니다.
- **이름의 중요성:** 이름은 코드의 의미를 명확하게 전달하고, 의사소통을 원활하게 합니다.
- **명명 방식:**
    - **snake_case:** 함수 이름, 변수 이름 (예: moon_beauty)
    - **camelCase:** (주로 Java 등에서 사용)
    - **PascalCase (CapWords):** 클래스 이름 (예: MoonBeauty)
- **실행 단위:** 명명은 **ASCII 문자**를 사용하는 것이 일반적입니다. (유니코드 문제 발생 가능성)
- **예약어 (Keyword) 사용 금지:** keyword 모듈을 통해 예약어 목록을 확인할 수 있습니다.

      `import keyword
print(keyword.kwlist) # 파이썬 예약어 목록 확인`

### 4. 숫자형 (Numeric Types)

- 파이썬의 숫자형은 **4가지** 주요 타입이 있습니다.
    - **int (정수):** sys.maxsize 를 넘어가는 **무한대 정수**를 지원합니다.
    - **float (부동소수점):** **근사값**을 표현하며, 연산 속도가 빠르지만 **정확하지 않을 수 있습니다.** sys.float_info 로 부동소수점 정보 확인 가능. inf (무한대), nan (Not a Number) 표현 가능.
    - **complex (복소수):** 허수부 표현에 j 를 사용합니다.
    - **bool (불리언):** True (1), False (0) 값을 가집니다. 파이썬 3에서 명확성을 위해 도입되었습니다.
- **숫자 연산:** 타입에 따라 연산 속도 및 방식이 다릅니다. 필요에 따라 숫자 타입 변환을 고려해야 합니다.
- **언더바(_) 구분자:** 숫자 리터럴 내에 언더바를 사용하여 **가독성**을 높일 수 있습니다. (예: 10_000)

      `a = 1000
b = 1e3  # 부동소수점 표현, a와 b는 내부 연산 방식이 다름
0.1 + 0.1 + 0.1 # 부동소수점 연산의 부정확성 예시`

### 5. 컨테이너 (Container) 데이터 타입

- **원자성 (Atomic) vs. 컨테이너 (Container):**
    - **원자적 (Atomic):** 더 이상 쪼갤 수 없는 데이터 (예: 숫자)
    - **컨테이너 (Container/Collection):** 쪼갤 수 있고, 쪼개도 의미가 있는 데이터 (예: 문자열, 리스트, 튜플, 딕셔너리, 셋)
- **컨테이너 분류:**
    - **호모지니어스 (Homogeneous):** 컨테이너 내부의 요소들이 **같은 데이터 타입** (예: numpy array, tensorflow tensor, 문자열, 바이트열)
    - **헤테로지니어스 (Heterogeneous):** 컨테이너 내부의 요소들이 **다른 데이터 타입** (예: 리스트, 튜플, 딕셔너리)
    - **시퀀스 (Sequence):** **순서**가 있는 컨테이너 (예: 리스트, 튜플, 문자열). **인덱싱 (indexing)과 슬라이싱 (slicing)** 가능.
    - **뮤터블 (Mutable):** **생성 후 내부 값 변경 가능** (예: 리스트, 딕셔너리, 셋, bytearray). 메모리 주소는 유지됨.
    - **이뮤터블 (Immutable):** **생성 후 내부 값 변경 불가능** (예: 튜플, 문자열, 숫자). 값 변경 시 새로운 객체 생성.

### 5.1. 문자열 (String)

- **시퀀스**, **호모지니어스**, **이뮤터블** 데이터 타입입니다.
- **유니코드 (Unicode):** 다양한 문자 표현을 지원하지만, **인코딩/디코딩** 문제가 발생할 수 있습니다.
- **바이트열 (Bytes):** **ASCII 문자**만 포함 가능. 인코딩/디코딩 없이 직접적인 바이트 값 처리. 통신, 파일 I/O 등에 사용. bytearray 는 뮤터블 바이트열. memoryview 를 통해 효율적인 메모리 접근 가능.

### 5.2. 리스트 (List)

- **헤테로지니어스**, **시퀀스**, **뮤터블** 데이터 타입입니다.
- 요소들의 순서가 있고, 다양한 타입의 요소를 담을 수 있으며, 내용 변경이 가능합니다.

### 5.3. 튜플 (Tuple)

- **헤테로지니어스**, **시퀀스**, **이뮤터블** 데이터 타입입니다.
- 리스트와 유사하지만, 요소 변경이 불가능합니다. **이뮤터블** 속성은 데이터 안정성을 높이고, 딕셔너리의 키 등으로 사용될 수 있게 합니다.
- **단축 표현 (Literal):** ( ) 괄호 없이 쉼표로 나열하여 튜플을 생성할 수 있습니다. (예: 1, 2, 3)
- **기본 데이터 타입:** 파이썬에서 튜플은 기본적인 데이터 구조로 취급됩니다.
- **연산자 우선순위:** 튜플 생성보다 연산자 우선순위가 높을 수 있으므로 주의해야 합니다. (예: 1, 2, 3 * 3 은 (1, 2, 9) 가 됨)
- **패킹 (Packing)과 언패킹 (Unpacking):**
    - **패킹:** 여러 값을 튜플로 묶는 것 (예: a, b, c = 1, 2, 3)
    - **언패킹:** 튜플 (또는 리스트 등 시퀀스)의 요소들을 개별 변수에 할당하는 것 (예: a, b, c = (1, 2, 3)). 언패킹 시 변수 개수와 요소 개수가 일치해야 합니다. * 를 사용하여 남은 요소들을 리스트로 묶을 수 있습니다. (예: a, b, *c = 1, 2, 3, 4)

### 5.4. 딕셔너리 (Dictionary)

- **매핑 (Mapping)** 데이터 타입입니다. **키 (Key)-값 (Value) 쌍**으로 데이터를 저장합니다.
- **헤테로지니어스**, **뮤터블**, **비-시퀀스 (순서 없음)** 데이터 타입입니다. (파이썬 3.7+ 부터는 순서가 보장되지만, 순서 기반 인덱싱은 지원하지 않음)
- **키 (Key):** **고유해야 하며, 이뮤터블 (immutable) 데이터 타입만 가능합니다.** (주로 문자열, 숫자, 튜플). **해시 가능 (hashable) 해야 합니다.**
- **값 (Value):** 어떤 데이터 타입이든 가능합니다.
- **키 중복:** 같은 키를 재할당하면 **기존 값**이 **새로운 값**으로 덮어씌워집니다.
- **딕셔너리 뷰 (Dictionary View):** dict.keys(), dict.values(), dict.items() 는 딕셔너리의 키, 값, 키-값 쌍에 대한 뷰 객체를 반환합니다. 뷰는 딕셔너리가 변경될 때 함께 변경되는 **동적인 뷰**입니다. 데이터 분석 시 유용하게 활용될 수 있습니다.
- **셋 (Set):** 딕셔너리의 키 구조를 활용하여 만들어졌습니다. 셋은 **중복된 요소를 허용하지 않는** 컬렉션입니다. 셋의 요소도 **해시 가능 (hashable) 해야 합니다.** (리스트는 해시 불가능하므로 셋의 요소가 될 수 없습니다.)

      `a = {'a': 1, 'b': 3, 'b': 7} # 키 'b'가 중복되어 마지막 값 7로 덮어쓰기됨
a = {2, 3, [4, 3, 4]} # TypeError 발생! 리스트는 해시 불가능하므로 셋 요소가 될 수 없음`

### 6. 연산자 (Operators)

- **비교 연산자 (Comparison Operators):** ==, !=, >, <, >=, <= 는 **불리언 값 (True, False)** 을 반환합니다.
    - **컨테이너 비교:** 컨테이너의 경우, **첫 번째 요소부터 순차적으로 비교**합니다. 첫 번째 요소가 같으면 다음 요소 비교, ...
- **존재론적 True/False:** 파이썬에서 True/False 판별은 값의 **존재 유무**에 기반합니다.
    - **False 로 취급되는 값:**
        - 숫자 0 (정수, 부동소수점)
        - 빈 문자열 ('')
        - 빈 컨테이너 (리스트 [], 튜플 (), 딕셔너리 {}, 셋 set())
        - None
    - **True 로 취급되는 값:** False 로 취급되는 값 외의 모든 값.
- **조건식 (Conditional Expression) / 삼항 연산자 (Ternary Operator):** value_if_true if condition else value_if_false 형태로, 조건에 따라 다른 값을 반환합니다.

      `if ['']: # 빈 문자열을 요소로 가진 리스트는 True로 평가됨 (리스트 자체가 비어있지 않으므로)
    print('a') # 출력: a
else:
    print('b')

b = 3 if True else 5 # 조건식이 True 이므로 b에 3 할당`

### 7. 제어 흐름 (Control Flow)

- **조건문 (Conditional Statements):** if, elif, else 를 사용하여 조건에 따라 코드 실행 흐름을 제어합니다.
- **반복문 (Loops):** for, while 을 사용하여 코드 블록을 반복 실행합니다.
    - **for-else 구문:** for 루프가 break 없이 **정상적으로 완료**되면 else 블록이 실행됩니다.
- **예외 처리 (Exception Handling):** try, except, else, finally 구문을 사용하여 예외를 처리하고 프로그램의 안정성을 높입니다.
    - **EAFP (Easier to ask for forgiveness than permission):** "허가보다 용서를 구하는 것이 쉽다." - 먼저 시도하고, 예외가 발생하면 처리하는 방식. 파이썬 스타일.
    - **LBYL (Look before you leap):** "뛰기 전에 보라." - 실행 전에 조건을 확인하여 예외 발생 가능성을 미리 방지하는 방식.
    - **assert 문:** assert condition, message 형태로, 조건이 False 일 경우 AssertionError 예외를 발생시켜 **디버깅**에 활용합니다.
    - **raise 문:** 강제로 예외를 발생시킵니다. raise Exception("에러 메시지") 와 같이 사용합니다.
    - **try-except-else-finally 구문:**
        - try: 예외가 발생할 수 있는 코드를 감쌉니다.
        - except: try 블록에서 발생한 특정 예외를 처리하는 코드를 정의합니다. 여러 except 블록을 사용할 수 있습니다.
        - else: try 블록에서 **예외가 발생하지 않았을 경우** 실행되는 코드를 정의합니다.
        - finally: try 블록 실행 **후 항상 실행**되는 코드를 정의합니다. (예외 발생 여부와 관계없이). 파일 닫기, 리소스 해제 등에 사용됩니다.
    - **try-else-finally 구문:** else 와 finally 는 for 구문에도 사용될 수 있습니다. finally 는 for 루프 종료 후 항상 실행됩니다. (숨겨진 finally 블록)

      `for i in range(3):
    print(i)
else: # break 없이 for 루프가 완료되었으므로 else 블록 실행
    print("for loop finished without break")

try:
    result = 1 / 0 # ZeroDivisionError 발생
except ZeroDivisionError:
    print("0으로 나눌 수 없습니다!")
finally:
    print("예외 처리 완료") # 항상 실행`