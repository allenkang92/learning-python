### 1. 파이썬 클래스 (Python Class) 와 객체 지향 프로그래밍 (Object-Oriented Programming, OOP)

- **객체 지향 프로그래밍 (OOP) 등장 배경:**
    - **Pre-OOP Days (OOP 이전 시대):** 코드 개발 속도에만 집중, 코드 설계 부족, 코드 재사용성 낮음 (복사 & 붙여넣기), 코드 가독성 저하 (스파게티 코드), 버그 추적 및 수정 어려움, 버그 수정 시 예상치 못한 문제 발생 (하류 시스템 문제).
    - **OOP 등장:** 코드 설계 우선, 코드 재사용성 향상, 모듈화 (명확한 인터페이스), 유지보수 및 수정 용이, 기존 객체와 약간 다른 새로운 객체 (클래스) 추가 용이.
- **OOP 예시: 은행 애플리케이션 (Banking Application):**
    - 다양한 계좌 유형 (checking accounts, savings accounts, money market accounts, lines of credit) 존재.
    - 계좌 유형별 **공통 데이터 필드** (account number, balance) 및 **공통 액션** (withdraw money, get balance) 존재.
    - 계좌 유형별 **특화된 데이터 및 액션** 존재.
    - **OOP 이전 방식**: 계좌 유형별 함수 컴포넌트 작성, 공통 데이터 필드 및 액션 중복 발생, 유지보수/디버깅 시 혼란 (어떤 데이터가 어떤 계좌 유형과 관련있는지 파악 어려움).
    - **OOP 방식**: 클래스 (Class) 와 객체 (Object) 활용.
- **OOP 원칙 - 클래스 (Class) 와 객체 (Object):**
    - **클래스 (Class):**
        - **객체 (Object) 를 만들기 위한 설계도 (blueprint), 템플릿 (template)**.
        - **사양 (specification) 집합**: 객체의 **데이터** 와 **메소드** 정의.
        - **구성 요소**:
            - **Initialized Data (초기화된 데이터):** 클래스 변수, 인스턴스 변수.
            - **Placeholders for Data (데이터를 위한 placeholders):** 속성 (attribute).
            - **Methods for Accessing and Manipulating Data (데이터 접근 및 조작 메소드):** 메소드 (method).
    - **객체 (Object):**
        - **클래스 (Class) 의 인스턴스 (instance)**. 클래스라는 설계도를 바탕으로 **실제로 만들어진 실체**.
- **파이썬 클래스 특징:**
    - **클래스 == 데이터 타입 (Class == Datatype):** 파이썬 2.2 버전부터 클래스가 새로운 데이터 타입을 정의하는 메커니즘으로 사용됨. int, float, str, list, dict 등 내장 타입들도 모두 클래스.
    - **type(a)**: 변수 a 의 데이터 타입 (클래스) 확인. type(1) 은 <class 'int'> (int 클래스).
    - **class A: pass**: A 라는 이름의 **새로운 클래스 정의**. pass 는 내용이 없는 빈 블록 나타냄.
    - **a = A()**: A() 는 클래스 A 를 **호출**하여 A 클래스의 **인스턴스 (객체)** 를 생성. a 는 인스턴스 객체를 가리키는 **식별자**.
    - **type(a)**: a 의 타입 확인. <class '__main__.A'> (main 모듈에 정의된 A 클래스).
    - **__main__**: 현재 실행 중인 파일 (main 모듈) 에서 정의된 클래스임을 나타냄.
    - **클래스 생성 == 새로운 데이터 타입 생성**: 클래스를 정의하는 것은 사용자 정의 데이터 타입을 만드는 것과 동일.
    - **TensorFlow Keras 예시**: tf.keras.models.Sequential 클래스는 딥러닝 모델 (Sequential 모델) 이라는 새로운 데이터 타입을 정의.
- **객체 지향 프로그래밍 (OOP) 장점**:
    - **코드 재사용성**: 상속 (Inheritance), 다형성 (Polymorphism) 등을 통해 코드 재사용성 향상.
    - **모듈화 (Modularity):** 클래스를 사용하여 코드를 모듈 단위로 묶어 관리 용이.
    - **유지보수성 (Maintainability):** 코드 구조 개선, 가독성 향상, 유지보수 용이.
    - **협업 (Collaboration):** 명확하게 정의된 인터페이스 (클래스, 메소드) 를 통해 협업 효율 증대.
    - **캡슐화 (Encapsulation):** 데이터와 메소드를 클래스 내부에 묶어 정보 은닉, 데이터 보호.
    - **추상화 (Abstraction):** 복잡한 구현 детали 숨기고, 인터페이스 (메소드) 를 통해 추상적인 기능 제공.

### 2. 상속 (Inheritance) 심화: 재사용성 극대화

- **상속 (Inheritance) 의 의미**:
    - **"물려받는다" (Inherit) 보다는 "재사용한다" (Reuse) 개념**: 파이썬 상속은 부모 클래스의 기능을 그대로 물려받는 것뿐만 아니라, **기존 코드를 재사용**하고 **확장**하는 데 초점.
    - **"이미 만들어진 것" 활용**: 이미 잘 만들어진 클래스 (부모 클래스) 를 **선택**하여 필요한 부분만 **취사선택**, **수정**, **추가** 하여 새로운 클래스 (자식 클래스) 생성.
    - **코드 재사용성 극대화**: 중복 코드 감소, 개발 생산성 향상.
- **클래스 A 정의:**

`class A:
    a = 1
    c = 3`

- **클래스 B 정의 (클래스 A 상속):**

`class B(A): # 클래스 A 상속
    b = 2
    c = 4 # 클래스 A 의 c 를 오버라이딩 (덮어쓰기)`

- **상속 관계**: B 클래스는 A 클래스를 상속받아 A 의 속성 (a, c) 을 **재사용**. B 클래스 자체적으로 b 속성 추가, c 속성 **오버라이딩**.
- **B.b**: B 클래스 자체에 정의된 클래스 변수 b 접근.
- **B.a**: B 클래스에서 a 속성 **직접 정의하지 않았지만**, 부모 클래스 A 로부터 **상속**받아 사용 가능.
- **id(B.a) == id(A.a)**: B.a 와 A.a 의 메모리 주소 (id) 가 **동일**. 파이썬 상속은 "물려받는다" 보다는 **"위임 (Delegate)"** 개념에 더 가까움. B 클래스가 A 클래스의 a 속성에 대한 접근을 A 클래스에게 **위임**.
- **B.c**: B 클래스에서 c 속성을 **오버라이딩** 했으므로, B.c 는 B 클래스에 정의된 값 (4) 반환. 부모 클래스 A 의 c 속성 (3) 은 가려짐.
- **LEGB 규칙과 델리게이트 (Delegate):**
    - **LEGB 규칙**: 변수 이름 검색 순서 (Local -> Enclosing -> Global -> Built-in).
    - **클래스 속성 접근**: 인스턴스 속성 -> 클래스 속성 -> 부모 클래스 속성 순으로 검색 (델리게이트).
    - B.a 예시: B 클래스에서 a 속성 검색 -> 없으면 부모 클래스 A 에서 a 속성 검색 -> 있으면 A.a 값 반환 (델리게이트).

### 3. 클래스 생성자 (__init__) 와 상속

- **class C: pass**: 빈 클래스 C 정의. dir(C) 로 속성 확인 시, __init__ 메소드 자동 생성 (object 클래스 상속).
- **class C: def __init__(self, a, b): ...**: C 클래스에 사용자 정의 __init__ 메소드 추가. 인스턴스 생성 시 C(2, 3) 와 같이 인자 전달 가능.
- **__init__ 오버라이딩**: 자식 클래스에서 __init__ 메소드 오버라이딩 시, 부모 클래스 __init__ 메소드 **자동 호출되지 않음**. 명시적으로 호출해야 부모 클래스 초기화 코드 실행 가능.
- **A.__init__(self)**: 자식 클래스 __init__ 에서 부모 클래스 __init__ **직접 호출**. 클래스 메소드 호출 방식이므로 self 인자 명시적으로 전달.
- **super().__init__()**: super() 를 사용하여 부모 클래스 __init__ 호출하는 방식. 다중 상속 환경에서 MRO (Method Resolution Order) 에 따라 부모 클래스 __init__ 호출, 다이아몬드 상속 문제 해결.

### 4. 다중 상속 (Multiple Inheritance) 과 MRO (Method Resolution Order)

- **다중 상속**: 클래스가 **두 개 이상** 의 부모 클래스 상속 가능. 파이썬 강력한 다중 상속 지원.
- **다이아몬드 문제 (Diamond Problem) 재확인**: 다중 상속 시 상속 관계 모호성 문제.
- **MRO (Method Resolution Order) 중요성**: 다중 상속 시 메소드 탐색 순서 (MRO) 가 중요. 파이썬 C3 선형화 알고리즘 사용.
- **D.mro()**: D 클래스의 MRO (메소드 탐색 순서) 확인. 리스트 형태로 반환. MRO 리스트 순서대로 메소드 탐색.
- **MRO 에러 (TypeError):** 다중 상속 관계가 **모순**되는 경우 (consistent MRO 생성 불가능), TypeError 발생.
- **super() 와 MRO**: super() 는 MRO 를 기반으로 부모 클래스 메소드 호출. 다중 상속 환경에서 super() 사용 필수적.
- **TensorFlow Keras Sequential 모델 MRO 예시**: tf.keras.models.Sequential.mro() 를 통해 TensorFlow Keras Sequential 모델 클래스의 복잡한 상속 계층 구조 및 MRO 확인. 다중 상속 활용 사례.

### 5. 메소드 (Method) 와 함수 (Function) 차이점 명확화

- **메소드 (Method):**
    - **클래스에 속한 함수**. 클래스 정의 블록 내에 정의.
    - **첫 번째 인자 self**: 인스턴스 메소드는 항상 첫 번째 인자로 self 를 받음. self 는 메소드를 호출한 **인스턴스 자신** 을 가리킴. PEP 8 스타일 가이드 권장 (필수 아님, but 컨벤션).
    - **인스턴스 통해 호출**: instance.method() 형태로 호출. 메소드 호출 시 인스턴스 객체가 self 인자로 **자동 전달**.
    - **클래스 네임스페이스**: 클래스 메소드는 클래스 네임스페이스에 속함.
- **함수 (Function):**
    - 클래스 **외부** 에 독립적으로 정의된 함수 (모듈, 글로벌 스코프).
    - **self 인자 없음**.
    - **함수 이름** 으로 직접 호출 (function()).
    - 모듈 또는 글로벌 네임스페이스에 속함.
- **A.x vs. a.x (클래스 vs 인스턴스 속성 접근):**
    - A.x: 클래스 A 의 x 속성 (함수 객체). 클래스 입장에서 x 는 **함수 (function)**. 클래스 이름으로 직접 접근. 함수 호출 시 self 인자 **명시적으로 전달** 필요 (A.x(a)).
    - a.x: 인스턴스 a 의 x 속성. 인스턴스 입장에서 x 는 **메소드 (method)**. 인스턴스 통해 접근. 메소드 호출 시 self 인자 **암묵적으로 전달** (생략).
- **dir(A)**: 클래스 A 의 속성 목록 확인. x 가 클래스 속성 (함수 객체) 로 포함됨.
- **dir(a)**: 인스턴스 a 의 속성 목록 확인. x 가 인스턴스 속성 (메소드 객체) 로 포함됨.

### 6. 클래스 메소드, 스태틱 메소드 활용: 네임스페이스, 유틸리티 함수

- **클래스를 네임스페이스로 활용**: 클래스를 단순히 관련 함수들을 **묶는 네임스페이스** 역할로 사용하는 경우.
- **스태틱 메소드 활용**: 클래스 네임스페이스에 속하지만, 클래스나 인스턴스 상태와 **독립적인 유틸리티 함수** 를 스태틱 메소드로 정의. 클래스 이름으로 직접 호출 가능 (Math.tan(3)).
- **@staticmethod 데코레이터**: 메소드를 스태틱 메소드로 지정. self 파라미터 불필요.
- **유지보수 용이성**: 관련된 함수들을 클래스라는 **범주**로 묶어 관리, 코드 **구조화**, **유지보수성 향상**.
- **Math 클래스 예시**: RightTriangle 클래스 예시 (hypotenuse, sin 스태틱 메소드).

### 7. 객체 지향 프로그래밍 (OOP) vs. 함수형 프로그래밍 (FP) 특징 비교 (심층 분석)

- **OOP (객체 지향 프로그래밍):**
    - **Encapsulation (캡슐화):** 데이터와 메소드를 **하나의 객체 (클래스)** 로 묶음. 정보 은닉 (information hiding) 통해 내부 구현 숨기고, 인터페이스 (메소드) 를 통해 외부와 상호작용. 낮은 결합도, 모듈화, 유지보수성 향상. But, 파이썬은 완벽한 정보 은닉 지원 X.
    - **Inheritance (상속):** 클래스 계층 구조, 코드 재사용성, 확장성, 다형성 확보. But, 다중 상속 시 복잡성 증가, MRO 중요.
    - **Polymorphism (다형성):** 상속을 통해 객체가 **다양한 형태** 를 가질 수 있도록 함. 동일한 메소드 호출에 대해 객체 타입에 따라 다른 동작 수행. 코드 유연성, 확장성 향상. 연산자 오버로딩 (Operator Overloading) 도 다형성의 한 형태.
- **FP (함수형 프로그래밍):**
    - **함수 (Function) 중심**: 계산 로직 함수로 캡슐화, side effect 최소화, 순수 함수 지향.
    - **Immutability (불변성):** 데이터 불변 (immutable) 객체 사용, 상태 변화 최소화, 프로그램 예측 가능성, 안정성 향상.
    - **Higher-Order Functions (고차 함수):** 함수를 인자로 받거나 반환하는 함수 활용, 코드 추상화, 재사용성, 모듈성 향상. map(), filter(), reduce() 등.
    - **Declarative Programming (선언형 프로그래밍):** "How (어떻게)" 보다는 "What (무엇)" 에 집중, 코드 간결성, 가독성 향상. 컴프리헨션, 제너레이터 활용.
    - **Recursion (재귀):** 반복문 대신 재귀 호출 활용, 특정 문제 해결에 우아하고 직관적인 표현 가능. But, 파이썬 재귀 성능, 스택 제한 고려 필요.
- **파이썬, Multiparadigm Language**: OOP, FP 모두 지원. 상황과 목적에 따라 **적절한 패러다임 선택** 또는 **혼합** 사용.
- **The Zen of Python**: "There should be one-- and preferably only one --obvious way to do it." (가장 명확하고 좋은 방법 하나를 지향). 파이썬은 다양한 패러다임 지원하지만, **핵심은 명확하고 간결한 코드**.