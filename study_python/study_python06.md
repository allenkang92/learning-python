### 1. Callable 객체 (Callable Object)

- **Callable 이란?**: **괄호 () 를 붙여서 호출 (실행) 할 수 있는 객체**. 함수, 클래스, 메소드, 클래스 인스턴스 등이 Callable 에 해당.
- **callable(객체)**: 객체가 Callable 인지 확인하는 내장 함수. True 또는 False 반환.
- **Callable 종류**:
    1. **함수 (Function):** def 키워드로 정의된 함수.
    2. **클래스 (Class):** class 키워드로 정의된 클래스. 클래스 이름으로 호출 시 **인스턴스 생성**.
    3. **메소드 (Method):** 클래스 내에 정의된 함수. 클래스 메소드, 인스턴스 메소드, 스태틱 메소드 모두 Callable.
    4. **클래스 인스턴스 (Class Instance):** 클래스의 __call__() 메소드 정의 시, 인스턴스를 함수처럼 호출 가능.
    5. **제너레이터 (Generator):** 제너레이터 함수 또는 제너레이터 표현식으로 생성된 객체. next() 함수로 호출 가능 (엄밀히 말하면 iterator protocol).
    6. **Built-in 함수/메소드**: print(), len(), list.append() 등 파이썬 내장 함수 및 메소드.
- **Callable 확인 방법**: dir(객체) 로 __call__ 메소드 존재 여부 확인. __call__ 메소드가 정의되어 있으면 Callable 객체.

### 2. 덕 타이핑 (Duck Typing)

- **"오리처럼 걷고 오리처럼 꽥꽥거리면 오리다"**: 객체의 **타입 (type) 보다는 "행동 (behavior)" 에 기반**하여 객체 타입 판단하는 방식.
- **파이썬 덕 타이핑**: 객체가 특정 메소드 (프로토콜) 를 **구현**하고 있다면, 해당 타입으로 간주. 상속 관계, 명시적 타입 체크 **불필요**.
- **이터러블 (Iterable) 덕 타이핑**: __iter__() 메소드 구현 시 이터러블 객체로 간주. 상속 관계 없이 이터러블 프로토콜 만족 여부로 판단.
- **시퀀스 (Sequence) 덕 타이핑**: __len__(), __getitem__() 메소드 구현 시 시퀀스 객체로 간주.
- **Callable 덕 타이핑**: __call__() 메소드 구현 시 Callable 객체로 간주.
- **유연성, 다형성**: 덕 타이핑은 코드 **유연성**과 **다형성** 높임. 특정 타입에 종속되지 않고, 필요한 기능 (메소드) 만 구현하면 호환 가능.

### 3. 클래스 (Class) 심화

### 3.1. 클래스 변수 (Class Variable) vs. 인스턴스 변수 (Instance Variable)

- **클래스 변수 (Class Variable):**
    - 클래스 **정의** 시 클래스 블록 내에 정의된 변수.
    - **클래스 자체** 에 속하는 변수. 클래스 이름으로 직접 접근 가능 (A.a).
    - 클래스의 **모든 인스턴스** 가 **공유**하는 변수. 인스턴스 간 공유되는 속성 (attribute) 에 사용.
- **인스턴스 변수 (Instance Variable):**
    - 인스턴스 메소드 (__init__, x 등) 내부에서 self.변수이름 형태로 정의되는 변수.
    - **각 인스턴스** 에 **개별적으로** 속하는 변수. 인스턴스마다 다른 값을 가질 수 있음.
    - 인스턴스 속성 접근 시, **인스턴스 변수** 먼저 검색, 없으면 **클래스 변수** 검색 (LEGB 규칙과 유사).
- **변수 접근**:
    - **클래스 변수**: ClassName.variable_name 으로 직접 접근.
    - **인스턴스 변수**: instance.variable_name 으로 접근.
- **변수 할당**:
    - **클래스 변수 할당**: ClassName.variable_name = value. 클래스 변수 값 변경, 모든 인스턴스에 영향.
    - **인스턴스 변수 할당**: instance.variable_name = value. 인스턴스 변수 **생성 또는 값 변경**. 해당 인스턴스에만 영향. 클래스 변수 가리지림 (shadowing).
- **vars(객체)**: 객체의 __dict__ 속성 (attribute dictionary) 반환. 인스턴스 변수 확인에 유용.

### 3.2. 클래스 메소드 (Class Method)

- **@classmethod 데코레이터**: 메소드를 클래스 메소드로 지정.
- **cls 파라미터**: 클래스 메소드의 첫 번째 파라미터는 **클래스 객체** (cls) 를 전달받음 (self 대신).
- **클래스 자체 조작**: 클래스 변수 접근, 클래스 팩토리 메소드 (인스턴스 생성 방식 커스터마이징) 등에 사용.
- **클래스 이름으로 직접 호출 가능**: ClassName.class_method()

### 3.3. 스태틱 메소드 (Static Method)

- **@staticmethod 데코레이터**: 메소드를 스태틱 메소드로 지정.
- **self 또는 cls 파라미터 없음**: 스태틱 메소드는 클래스 또는 인스턴스 객체를 **암묵적으로 전달받지 않음**.
- **클래스 네임스페이스 활용**: 클래스를 **네임스페이스** 로 활용, 관련 함수들을 **묶어서 관리**하기 위해 사용.
- **클래스 이름 또는 인스턴스 이름으로 호출 가능**: ClassName.static_method(), instance.static_method().
- **객체 상태 (state) 와 무관**: 스태틱 메소드는 클래스 또는 인스턴스 상태에 접근하지 않음. 순수 함수 (pure function) 에 가까움.
- **유지보수 용이**: 관련된 기능들을 클래스 네임스페이스 안에 묶어 코드 **구조화**, **유지보수성 향상**.

### 3.4. __new__ vs. __init__ 메소드

- **__new__(cls, ...)**:
    - **클래스 메소드 (staticmethod)**. 클래스 인스턴스 **생성** 담당.
    - **첫 번째 단계**: 객체 생성 과정의 **가장 먼저 호출**되는 메소드.
    - **cls 파라미터**: 클래스 객체 자체를 인자로 받음.
    - **super().__new__(cls)**: 일반적으로 superclass 의 __new__() 메소드 호출하여 인스턴스 생성.
    - **반환값**: **새로운 인스턴스 객체** 를 반환해야 함.
    - **주요 용도**: 불변 타입 subclass 에서 인스턴스 생성 방식 커스터마이징, metaclass 에서 클래스 생성 커스터마이징.
- **__init__(self, ...)**:
    - **인스턴스 메소드**. 인스턴스 **초기화** 담당.
    - **두 번째 단계**: __new__() 호출 **후** 호출.
    - **self 파라미터**: 생성된 인스턴스 객체를 인자로 받음.
    - **반환값**: **None 반환** (명시적 반환값 X).
    - **주요 용도**: 인스턴스 변수 초기화, 객체 속성 설정.
- **생성 vs 초기화**: __new__() 는 객체 **생성**, __init__() 는 객체 **초기화**. 객체 생성과 초기화 단계 분리.

### 4. Callable 객체 심화 (다양한 Callable 종류 복습)

- **다양한 Callable 객체**:
    1. **Named functions (비익명 함수):** def 로 정의된 일반 함수. __qualname__ 속성 가짐.
    2. **Anonymous functions (익명 함수):** lambda 로 생성된 람다 함수. __qualname__ 속성 없음 (default <lambda>). 주로 콜백 함수, 간단한 일회성 함수에 사용.
    3. **Instances of classes with __call__():** __call__() 메소드 정의된 클래스의 인스턴스. 함수처럼 호출 가능.
    4. **Closures (클로저):** 함수 팩토리 (function factory) 가 반환하는 클로저. 데이터 캡슐화, 정보 은닉에 유용.
    5. **Static methods:** @staticmethod 데코레이터 또는 클래스 __dict__ 통해 정의된 스태틱 메소드. 클래스 네임스페이스 활용, 객체 상태와 무관.
    6. **Generator functions:** yield 키워드 사용 함수. 호출 시 제너레이터 객체 반환. Lazy evaluation, 메모리 효율성.
- **메소드 (Methods):** 클래스 인스턴스 메소드, 클래스 메소드, 스태틱 메소드 모두 Callable. 인스턴스 메소드는 뮤터블 상태 (mutable state) 접근 및 변경에 주로 사용 (OOP 스타일).

### 5. 함수형 프로그래밍 vs. 객체 지향 프로그래밍 (FP vs. OOP) 비교

- **클래스 (OOP):** "Data with operations attached" (데이터에 연산이 붙어있는 형태). 뮤터블 상태 (mutable state) 강조. 인스턴스 상태 변경 메소드 (mutable methods) 활용.
- **클로저 (FP):** "Operations with data attached" (연산에 데이터가 붙어있는 형태). 이뮤터블 (immutable) & 순수 함수 (pure function) 강조. 데이터 불변, 함수 side effect 최소화.
- **목적과 철학 차이**: 클래스는 뮤터블 상태 관리, 객체 간 상호작용, 코드 모듈화, 유지보수성에 초점. 함수형 프로그래밍은 불변성, 순수 함수, side effect 최소화, 형식적 증명 가능성에 초점.
- **Python, Multiparadigm Language**: 파이썬은 OOP, FP 모두 지원하는 다중 패러다임 언어. 상황과 목적에 따라 적절한 패러다임 선택 중요.

### 6. 파이썬 철학 (Zen of Python) 복습

- **import this**: "The Zen of Python" (파이썬의 선, 파이썬 철학) 출력.
- **Tim Peters 작성**: 파이썬 디자인 철학, 코딩 지침 제시.
- **핵심 메시지**: "There should be one-- and preferably only one --obvious way to do it." (어떤 일을 하는 **명확한 방법은 하나**여야 한다). 파이썬의 **단순성**, **명확성**, **일관성** 강조. 하지만 "Although practicality beats purity." (실용성이 순수성보다 중요하다) 와 같이 **융통성** 또한 강조.
- **다양한 해석 가능**: "There should be one-- and preferably only one --obvious way to do it." 문구는 다양한 해석 가능. 방법이 여러 개일 수 있지만, **가장 명확하고 직관적인 방법** 을 선택하는 것이 중요. 멀티 패러다임 언어인 파이썬에서 다양한 해결 방법 존재 가능성 암시.

### 7. 함수 vs. 클래스: 역할과 특징 비교

- **함수, 클래스, 인터체인지 가능성**: 함수를 클래스로, 클래스를 함수로 변환 가능. 파이썬 유연성.
- **함수 vs 클래스: 특화된 영역**: 함수와 클래스는 역할과 기능 면에서 미묘한 차이 존재.
- **함수**: 코드 묶음, 특정 기능 수행, 재사용성, 모듈화. 괄호 () 를 통해 호출 (실행) 연상. 익명 함수 (람다 함수) vs 비익명 함수 (def 함수).
- **클래스**: 데이터와 메소드 묶음, 객체 생성, 상태 관리, 상속, 다형성. 객체 (인스턴스) 생성, 속성/메소드 접근 연상. 네임스페이스 역할 (관련 함수, 클래스 묶음).
- **재사용성**: 함수, 클래스 모두 코드 재사용성 높이기 위해 사용.
- **시그니처 (Signature) 중요**: 함수, 클래스 정의 시 시그니처 (이름, 파라미터, 역할) 명확하게 설계 중요.

### 8. 함수 속성: __name__, __qualname__

- **__name__**: 함수, 클래스, 메소드 이름 (문자열).
- **__qualname__**: qualified name (qualified name). 모듈, 클래스 정보 포함한 **fully qualified name**. 클래스, 함수 이름 충돌 방지, 디버깅, introspection 에 유용. 람다 함수는 __qualname__ 속성 없음 (익명 함수).
- **함수 이름 변경**: __qualname__ 속성 변경 가능 (but 일반적인 사용법은 아님).

### 9. Named Functions vs. Lambdas (비익명 함수 vs. 익명 함수)

- **Named Functions (비익명 함수):** def 키워드로 정의, 이름 가짐 (__name__, __qualname__ 속성). 재사용성, 모듈화, 디버깅 용이.
- **Anonymous Functions (익명 함수):** lambda 키워드로 정의, 이름 없음. 일회성, 간단한 기능, 콜백 함수 등에 주로 사용. 표현식 내에 inline 으로 작성 가능.
- **본질적인 차이**: __qualname__ 속성 유무 (이름 유무). 기능적 차이 거의 없음.
- **람다 함수 활용**: 콜백 함수, 간단한 함수 인자 전달, 컴프리헨션, map(), filter(), reduce() 등 함수형 프로그래밍 기법 활용 시 유용.
- **함수 유용성**: 렉시컬 스코프 (lexical scope) 를 통해 상태 격리 (state isolation), namespace 오염 방지. 함수 내부에서 변수 정의 시, 함수 외부 스코프 변수와 이름 충돌 방지.

### 10. 클로저 심화 (Closure) 복습 및 활용

- **클로저 복습**: 함수 + 자유 변수 조합, 함수 팩토리 (function factory) 로 생성.
- **클로저 활용**: 데이터 캡슐화, 정보 은닉, 데코레이터 구현, 팩토리 함수 구현 등.
- **클래스 vs 클로저**: 클래스와 클로저는 "데이터 + 연산" 묶는다는 공통점, but OOP vs FP 패러다임 차이 반영. 클래스는 뮤터블 상태, 클로저는 이뮤터블, 순수 함수 지향.
- **클로저 변수 바인딩 주의**: 클로저 내부에서 자유 변수 바인딩 시, 이름 (name) 기준 바인딩 (값 기준 바인딩 X). 루프 내에서 클로저 생성 시 의도치 않은 동작 발생 가능.
- **Keyword Argument Scope-Binding Trick**: 람다 함수 파라미터에 default 값 할당 (lambda m, n=n: m+n) 하여 클로저 변수 값 바인딩 문제 해결. 키워드 인자 scope binding trick 사용 시, 클로저 생성 시점의 변수 값 캡처 가능.

### 11. 클래스 vs. 클로저: Adder 예제 비교

- **Adder 클래스 (OOP 스타일):**
    - Adder 클래스 정의, __init__, __call__ 메소드 구현.
    - add5_i = Adder(5): Adder 클래스 인스턴스 생성 (add5_i).
    - add5_i(10): add5_i 인스턴스 호출 (__call__ 메소드 실행), 5 + 10 = 15 반환.
    - **뮤터블 상태 (mutable state):** add5_i.n = 10 와 같이 인스턴스 속성 n 값 변경 가능. 인스턴스 상태 변경에 따라 add5_i(10) 호출 결과 달라짐 (side effect).
- **make_adder 함수 (FP 스타일, 클로저):**
    - make_adder(n) 함수 정의, 내부 함수 adder(m) 정의 및 반환 (클로저 생성).
    - add5_f = make_adder(5): make_adder(5) 호출 -> 클로저 adder 반환 (add5_f).
    - add5_f(10): add5_f (클로저 adder) 호출, 5 + 10 = 15 반환.
    - **이뮤터블 (immutable) & 순수 함수 (pure function):** 클로저 add5_f 는 외부 상태 변경 X, 항상 동일 입력에 대해 동일 출력 보장.
- **클래스 vs 클로저 비교**: Adder 예제를 통해 OOP (클래스) 와 FP (클로저) 스타일 비교. 클래스는 뮤터블 상태, 클로저는 이뮤터블, 순수 함수 지향.

### 12. 텐서플로우 Keras Sequential 모델 vs. 클로저

- **TensorFlow Keras Sequential 모델**: 딥러닝 모델 **구현 방식** 중 하나. 레이어를 **순차적으로 쌓아서** 모델 구성.
- **클래스 기반 모델**: tf.keras.models.Sequential 클래스 사용, 인스턴스 생성, 레이어 추가 (add() 메소드). OOP 스타일.
- **클로저 기반 모델 (함수형 모델):** 함수형 API 또는 custom training loop 등을 통해 클로저 형태로 모델 구현 가능. FP 스타일.
- **구조체 튜닝 (Architecture Tuning):** 모델 구조 (레이어 구성, 연결 방식) 변경 용이성. 클로저 기반 모델은 유연성 높음, 다양한 구조체 실험 용이. 알고리즘 하이퍼파라미터 튜닝 (모델 구조 튜닝) 에 유리.
- **유연성 확보**: 클로저 (함수형 모델) 는 유연성 높여 **다양한 구조체** (모델 아키텍처) 쉽게 실험 가능. 시뮬레이션, 실험 중심 연구 개발에 유용. 추상화 용이.
- **데코레이터 (펑션 클로저) 활용**: 데코레이터는 펑션 클로저의 한 형태. 함수 기능 확장, 추상화, 코드 재사용성 향상.